# -*- coding: utf-8 -*-
"""ML_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1--cpsi8NBurT-1KUOOqnNmg-J_0c4ds8

**Part 3) Write a function that estimates the emission parameters from the training set using MLE (maximum
likelihood estimation):** 
\begin{align}
  q(y_{i-1}, y_i) = \frac{\text{Count}(y_{i-1}, y_{i})}{\text{Count}(y_{i-1})}
\end{align}

We first have an array of the $m$ different labels:
\begin{align}
\begin{bmatrix}
  y^{(0)} & y^{(2)} & ... & y^{(m+1)} 
\end{bmatrix}
\end{align}

where $y^{(0)}$ is the 'start' label and $y^{(m+1)}$ is the 'stop' label. We now look to generate an $(m+2) \times (m+2)$ matrix where each entry denotes the transition parameter from label $y^{(i)}$ to $y^{(j)}$. This matrix will look as follows: 
\begin{align}
\begin{bmatrix}
  q(y^{(0)}, y^{(0)}) & q(y^{(0)}, y^{(1)}) &  ... & q(y^{(0)}, y^{(m+1)}) \\
  q(y^{(1)}, y^{(0)}) & q(y^{(1)}, y^{(1)}) & ... & q(y^{(1)}, y^{(m+1)})\\
  \vdots & & \ddots & \vdots  \\
  q(y^{(m+1)}, y^{(0)} & q(y^{(m+1)}, y^{(1)}) & ... & q(y^{(m+1)}, y^{(m+1)})
\end{bmatrix}
\end{align}

The superscripts are to differentiate between being a different label and a label instance in the data set.
"""

import numpy as np
import itertools 


# function preprocesses data 
# def pre_process(data):
  
#   # block that segments features and labels
#   X = {} # word dict (keys: words, values: no. of words) 
#   Y = {} # sentiment dict (keys: sents, values: no. of sents)
  
#   # creating a library labels as keys and values as assigned indices
#   sent_list = Y.keys() # list of sentiments (assigning indices to labels) 
#   sents = {} # library
#   for i in range(len(sent_list)):
#     sents[sent_list[i]] = i
  
#   return X, Y, sents




def transition_params(data, Y, sents):
  # data: features and labels
  # Y: dictionary with sentiment and counts
  # sents: dictionaty with sentiments and indices
  
  q_uv = np.zeros([len(Y.keys()), len(Y.keys())]) # 2D array transitions
  
  # counting u,v transitions for all u,v
  for y in range(1, len(data)):
    
      # comparing data labels with sentiment keys
      label_i = sents.get(data[y][1])
      label_im1 = sents.get(data[y-1][1])
      
      # filling up transition matrix
      q_uv[label_im1, label_i] += 1/Y.get(data[y-1][1])
      
  return q_uv


# simplet test
data = [['Hello', 'NT'], ['my', 'NT'], ['name', 'NT'], ['is', 'NT'], ['Reuben','NT'], ['and', 'NT'], ['I', 'NT'], ['like', 'P'], ['Science', 'P']]
Y = {'NT':7, 'P':2, 'N':0}
sents = {'P':0, 'N':1, 'NT':2}

print (transition_params(data, Y, sents))


def viterbi_algo(emissions, transitions):



